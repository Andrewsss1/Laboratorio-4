TRASFERIMENTO DATI
I tunnel non memorizzano appunti, il dato che gli dai all'inizio se lo portano per sempre. Lo scopo di un ciclo è quello di fare iterazioni successive. Nei loop di usano gli shift register che memorizzano il valore del dato che gli sta arrivando in uscita e lo usano come input dell'iterazione successiva. Questi shift-register possono essere anche multipli. Il dato in uscita viene messo nella colonnina degli shift-register e così via. Un modo per piazzare shift register: tasto dx + replace qith shift register.Posso dover utilizzare i dati che provengono dalla prima iterazione in un modo e dalla seconda in un altro, is mettono quindi in stack. 
Quello che si deve fare nell'esercizio è modificare il lopp in modo che invece che plottare la temperatura instantanea plotti la media degli ultimi tre dati di temperatura, si usano i loop in stack. 

DECISION MAKING
E' una case structure che esegue una parte di codice se avviene una certa cosa oppure ne esegue un'altra se succede un altro fatto. E' un rettangolo che è composto dall'etichetta ed è quella in cui si inseriscono i casi ed è quella a cui diciamo cosa fare. 
Il selector è quello che determina quale caso eseguire e gli possiamo inserire qualsiasi tipo di dato. 

ESPERIENZA DI LABVIEW
Ci carica una cartella dove all'interno ci sono i vi implementati dalle case produttrici degli stumenti. Nel codice ci sono molte cose che lei non ha spiegato ma non saranno chieste all'esame. Si apre sempre prima il project explorer, in questo ci deve stare sol il main e si deve aprire quello. Se non ci sta solo il main vuol dire che è gestito male. Si deve costruire un circuito RC e trovare una frequenza di risonanza. Noi abbiamo un generatore di funzione e un oscilloscopio. Costruisci un circuito a mano
C'è un conticino da fare, uno solo. NEl momento in cui l'esperienza prevede altro, se ti metti a fare i conti in lab e non ci criesci vuol dire che non vi siete letti la scheda a casa. Arrivate già pronti altrimenti si incazza la prof. Ci vuole un'ora a fare questo, quindi fatelo altrimenti lei perde la pazienza. Sulla shceda c'è tutto.
Voi avete: basetta + oscilloscopio + generatore di fuzione. L'oscilloscopio non lo dovete toccare. Il senso dell'esperienza è far capire la differenza tra quello che avete fatto. Noi siamo gli utenti che possono solo premere "start", ma dobbiamo sapere quello che sta succendo quando premiamo start, questa cosa la spiega lei oggi. Adesso pausa ciao, quello che dovete aspettare è che voi avete un circuito da montare + generatore + oscilloscopio. Lei ciporta è una serie di cavi, fate in modo che sull'oscilloscipio vedete due cose: segnale in ingresso e segnale di uscita e si devono vedere entrambi. 
Si accende il pc, mettere spina, accendere programma. Trovare una mezza giornata dove nessuno seguiamo per fare l'esperienza i LabView altrimeniti dobbiamo dividerlo in due. Per ogni strumento devi selezionare la porta in cui lo strumento è inserito. 
Block diagram:
Sono controlli o indicatori? Controlli di tipo numerico, clicchiamo due volte e si sono numerici perchè sono arancioni: non sono interi. A meno che no siate assolutamente sicuri che il numero sia sempre un intero mettete il float, la rappresentazione si cambia con il tasto destro e poi su representation. Si usa o la double o i32. Cosìè la barra sotto? Indicatore numerico che invece di far vedere un numero fa vedere una barra che si riempie, è un indicatore perchè non ci puoi agire. Poi vediamo che ci sono due tasti di start e stop sono controlli booleani. Poi c'è un grafico: indicatore. Che vuol dire grafico? E? un indicatore cluster, ha una serie di tipi di dato. Quando chiede cos'è vuole sapere se è controllo e indicatore e che tipo di dati ha. Sui cluster non fa domande perchè non li abbiamo visti. Adesso vediamo ilm codice. E' implementato con una simple-state machine che è uno dei modi di programmare in LabView. Questo ha dei design per disegnare i programmi. Il design più semplice è la simple state machine che al suo intenro ha un while e una case structure, poi dentro di questi ci possono essere altri loop e altre strutture ma come cosa più grande ha una case e un while. Perchè questo? Perchè stando solo a guardare e interagendo con l'interfaccia utente, puoi fare tutto quello che ti serve a seconda dello stato in cui sta il codice. Cominciamo dalla parte più esterna: è un ciclo while che ha un bottone di stop. A sinistra ci sono gli input che devono essere inizializzati e a dx ci sono gli output ci sono dei VI chw sono quelli che chiudono e resettano gli strumenti. C'è poi anche la finestrella id errore che spiega l'errore. Adesso facciamo una piccola modifica, dove sta il pulsante di stop non ci sarà questa derivazione con questo pulsante. Tale derivazione fa in modo che il programma subito si ferma trova un errore senza fare tutto, questo serve perchè uno subito vede dove sta l'errore senza far girare tutto. E' una funzione "jfnrj by name" (non viene chiesta), è una funzione che si prende uno dei tipi di dato presente nell'errore (che è un cluster), che dice esci se trovi False invece di True per esempio.Noi lo facciamo con il booleano perchè ci serve che il codice esce dal while quanod trova il booleano. Poi c'è una funzione di and, fa attaccare una serie di input e fa fare qualcosa su quegli input. E' stato selezionato il caso di or, perchè è una funzione che quando gli metti or confronta i booleani e appena uno diventa True o False (non si ricorda) esce dal ciclo. Gli è collegato il pulsante di stop e un altro filo, serve a uscire dal while quando il programma è finito. 
Andiamo a vedere stato per stato che succede. Quanti casi sono previsti? 6. C'è uno stato che si chiama initialize (sturt up), configura, wait for event (codice in pausa che aspetta l'utente che faccia qualcosa), state one e state non so cosa (prende i dati), shut down (stop/save). 
Andiamo avedere passo passo che cosa succede. Accendiamo la lampadina e premiamo run. Immaginiamo di aver collegato tutti gli strumenti. 
INITIALIZE
I due quadratini con disegnini dentor sono sub-VI, sono quelli dati e sono quelli delle case. Il 1° è del generatore e il 2° è dell'oscilloscopio (hanno tutti una barra rossa sopra e c'è scritta la marca dello strumento). All'intenro dell'icona c'è un disegno che spiega che sta facendo in quel momento. Quello che fanno è inizializzare gli strumenti, gli diamo come input l'indirizzo dei due strumenti. In uscita che hanno? nulla in realtà hanno un indirizzo che arriva al cluster destro e poi hanno l'uscita dell'errore che serve per avere una sequenza. L'errore è collegato perchè in questo modo guarda prima il generatore e poi l'oscilloscopio, dopodichè prosegue. 
Il punto del cluster è che i dati devono essere selezionati per essere usati che si chiama o unboundle o unboundle by name, il filo del cluster arriva alla funzione cliccando con la freccia su quetse finestre puoi selezionare qualce tipo di dato vi serve. Nella fase di inizialize abbiamo selezionato tutto   in realtà. A ognuno di questi ingressi sta arrivando qualcosa. Noi vediamo numero di step, ampiezza e non so altro che sono cose che decidiamo noi. Dopodichè va messo all'interno il type numerator che il menu a tendina con i casi, però non deve essere un controllo perchè non deve essere l'utente a decidere in che caso andare ma lo deve fare il programma in bade a cosa gli serve. Cosa passa all'esterno? Il cluster, l'errore e un valore che è collegato allo shift register, a questo shift gli arriva lo stato successivo che entra nel loop in modo che lo stato di dopo sarà quello che ci serve. Nel caso di inizialize abbiamo come stato successivo configure e il codice ci va da solo. Nello stato di start up si accendono le cose in quello di configure vuol dire che noi gl andiamo a dare qualcosa.
CONFIGURE
Vedimao l'unboudle by name, ora ci andiamo a prendere il valore. Tiriamo il filo e mettiamo l'unboundle by name e vediamo cosa ci andiamoa  prendere. Che ci serve? i due indirizzi degli strumenti. Due cose che servono solo per il generatore: ampiezza e frequenza che osno collegati al driver del generatore. Dopodichè arriva l'oscilloscopio e gli emttiamo tre driver: uno per configurare canale 1, uno canale 2 e uno per il trigger. Tutte le costanti che vedete servono per configurare il canale, dici al driver che canale configurare. Noi potremmo tenere tutti e 4 per avere i 4 canali, però se io voglio farlo funzionare con un solo canale io posso anche dirgli di chiudere un canale senza eliminarlo.Potremmo metterli disabilitandoli, qua non è stato fatto perchè è un programma che serve solo a noi. 
Per tutti gli ingressi che vedete ne abbiamo attacato solo due: canale e pc. Non c'è altro da dire su questo stato. Finito questo, c'è una cosa che va prevista in tutti glo stati ossia lo stato successivo. In tal caso è WAIT FOR EVENT, che deve essere passato allo shift register.
WAIT FOR EVENT
si mette qui ed esce questa finestrella che è una finestra che abbiamo previsto noi è una "diagram(?) box" (tutte ste funzioni sono spiegate con il context help! In questo caso esce un messaggio con scritto "start to aquirw". Ha un bottone collegato che è di tipo stringa, nel momento in cui dici "ok" la finestra si chiude e succede qualcosa. La finestra di dialogo ti fa solo scrivere e vede che tu hai premuto ok. Quello che da il cambio del valore dle booleano è un'altra struttura detta non so come "ivec?" è una struttura che fa qualcosa quando l'utente fa qualcosa, se non fai niente lei sta lì e aspetta. Cioè aspetta un'interazione. 
STATO CHE FA COSe
Si legga la frequenza, ampiezza, step. Fa le varie cose, si legge i dati e li mette sul grafico. Nel momento in cui lo vedi eseguire è molto semplice, sono operaizoni banali. Presenza di due funzioni. Ci sono alcune funzioni che accettano solo tipo di dato float e non intero e abbiamo anche detto che può cambiare da sola il tipo di dato ed esce il pallino rosso. In questo caso non si può fare, peerchè in input arriva alla funzione lo step che è un intero. Si usa una funzione quindi che cambia la rappresentazione, cosa cambia? niente, ma è una buona abitudine perchè non sempre la funzione poi ti dà la cosa corretta, è meglio farla noi la conversione. 
Il cambio di rappresentazione può esserr fatto tra tutti i tipi di dati numerici in questo caso noi facciamo da intero a double.
C'è il driver dell'oscilloscopio che organizza il tempo (non vi soffermate) e uno che dice al generatore che frequenza mettere, noi lo sappiamo ma lui no e glielo dice il driver. E' un driver giallo vuol dire che è implementato in LabView, si usa per parlare con gli strumenti ogni volta che gli strumenti non hanno dei driver della casa produttrice. Non lo aprite o fatelo per curiosità, scherzavo non si apre. 
Finito lo stato di acquisizione delle x. c'è una derivazione del filo che a seconda dle numero la barra si colora, se non mettiamo l'indicatore (?) non vediamo la barra, serve per vedere lo stato di acquisizione. 
STATO 2
E' la lettura. Prendiamo il driver per l'oscilloscopio e gli andiamo a dire in che canale vogliamo leggere. E' una cosa che dobbiamo controllare, a seconda di quale canale metti l'oscilloscopio noi dobbiamo andarlo a leggere.quindi controlla che canale ci sta messo perchè se ci sta scritto 2 tu lo metti a 1 non va.
Gli diciamo che canale deve leggere, e ora dobbiamo  dirgli che vogliamo leggere, gli diciamo di legger el'ampiezza picco-picco.  Ci sono delle costanti che all'utente non servono e non deve vedere. stiamo andando a riempire il cluster data y. A che stato andiamo dopo?Ci vuole la funzione select che in ingresso ha un booleano che a seconda dello stato che assume sceglie se dare in uscita quello che gli hai dato sopra o quello che gli hai dato sotto in ingresso. Gli diciamo se lo stato è vero, torna allo stato 1, se invece è falso dagli lo stato di shut down. Da dove esce lo stato dal confronto di non so cosa con lo step. 
Metto un numero di step e lo confronta con lo stato di avanzamento che ha fatto il codice, ossia a che step siamo della lettura e dell'acquisizione.Fino a quando non sono uguali qua esce sempre una variabile true e gli stati sono sempre uguali. Quando sono uguali esce il false e la funzioen select ci manda allo stato save. 
SAVE
C'è uno stato dentro che gli dice di ripartire da inizialize ma in realtà non serve perchè il programma lo farebbe da solo. Prendiamo i dati dal cluster che ha degli array con x e y. Li portiamo a un sub-VI. E' un dischetto che salva i dati, ti si apre una finestra che ti dice di dare un nome al file e si salvano i dati a un file excel. La costante TRUE, passa alla funzione di stop, la funzione che gli confronta i booleani legge i valori ed esce. Essendo il True una costante il programma esce per forza. E' collegato con il filo a un or, arriva alla funzione or.  LA funzione or vede un falso e vede un vero, si porta sul conditional terminal e dice al loop di chiudersi. Ora si è chiuso il loop non il programma. 
Fuori dal loop cosa ci sta? Legge il valore vero del save, si porta tutti i dati che ha sul lato destro del while e li porta fuori. Cosa fa? C'è lo stesso VI che abbiamo visto prima per dire al generatore di fare qualcosa e dice al generatore di chidersi. Dopo passa a due driver dell'oscilloscpio: uno resetta le impostazioni e l'altro chiude il canale. Il programma ora è finito, ce lo passa con la modifica che ha l'uscita dal programma senza il filo di errore.
Il programma si può vedere con calma anche dopo la cosa importante è la scheda. Provare a risolvere l'esercizio e poi passare al programma. 